import numpy as np

def neighbourhood_exploration(X,n,max_r, fitness, C_X):
    #update r
    r = min(max_r, np.exp(2 * (abs(fitness["current"] - fitness["previous"]) / abs(fitness["best"] - fitness["initial"]) - 1)))

    new_sols = [(X, evaluate_fitness(X))]
    for i in range(n):

        #changes
        U = np.random.uniform(0, 1, size=X.shape)

        #vector template if apply change
        V = np.random.randint(0, 2, size=X.shape)

        sol = X + V * (U * 2 * r - r)
        f_sol = fitness_func(sol)
        new_sols.append((sol, f_sol))

    #sort solutions
    new_sols.sort(key=lambda s: s[1])
    new_sols= new_sols[:-1]
    n = len(new_sols)

    # distribute Cx
    new_cardinality = [C_X // n + (1 if i < C_X % n else 0) for i in range(n)]

    # update individuals 
    results = [{"X": sol[0], "fitness": sol[1], "C_X": c}
               for sol, c in zip(new_sols, new_cardinality)]

    return results
