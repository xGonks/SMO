import numpy as np

from generate import generate
from evaluate_fitness import evaluate_fitness

def exploitation(X,n,max_r,iter,fits,C_X):
    #update r
    r = min(max_r, np.exp(2 * (abs(fits[iter] - fits[iter-1]) / abs(min(fits) - fits[0]) - 1)))

    #new_sols = [(X, evaluate_fitness(X))]
    new_sols = [[X,fits[iter]]]
    path = [X]
    path_fits = [fits[iter]]
    for i in range(n):
        sol = generate(X, r)
        sol_fit = evaluate_fitness(sol)
        new_sols.append([sol,sol_fit]) 
        path.append(sol)
        path_fits.append(sol_fit)

    #sort solutions
    new_sols.sort(key=lambda s: s[1])
    new_sols= new_sols[:-1]
    m = len(new_sols)

    # distribute Cx
    new_cardinality = [C_X // m + (1 if i < C_X % m else 0) for i in range(m)]

    # update individuals 
    for i in range(m):
        if new_cardinality[i]==0:
            new_sols.pop(i)
            new_cardinality.pop(i)

    new_inds=[]
    new_fits=[]
    for item in new_sols:
        new_inds.append(item[0])
        new_fits.append(item[1])

    return new_inds,new_fits,new_cardinality,path,path_fits
