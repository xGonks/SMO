import numpy as np
from evaluate_fitness import evaluate_fitness
from generate import generate

def exploitation(X, n, max_r, iter, fits, C_X, scenario, all_fits):
    if iter > 0 and len(all_fits) > 1:
        f_t = all_fits[-1]
        f_t_1 = all_fits[-2]
        f_best = min(all_fits)
        f_0 = all_fits[0]
        ratio = abs(f_t - f_t_1) / (abs(f_best - f_0) + 1e-9)
        r = min(max_r, np.exp(np.clip(2 * (ratio - 1), -5, 5)))
    else:
        r = np.random.uniform(0.1, max_r)

    new_individuals = []
    new_fits = []
    path = []
    path_fits = []
    for _ in range(n):
        X_new = generate(X, r)
        f_new = evaluate_fitness(X_new, scenario)
        new_individuals.append(X_new)
        new_fits.append(f_new)
        path.append(X_new)
        path_fits.append(f_new)
    sorted_indices = np.argsort(new_fits)
    new_individuals = [new_individuals[i] for i in sorted_indices]
    new_fits = [new_fits[i] for i in sorted_indices]
    n_valid = len(new_individuals)
    new_cardinality = [C_X // n_valid + (1 if i < C_X % n_valid else 0)
                       for i in range(n_valid)]

    return new_individuals, new_fits, new_cardinality, path, path_fits
